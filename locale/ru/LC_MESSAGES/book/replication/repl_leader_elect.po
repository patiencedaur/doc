
msgid "Automated leader election"
msgstr ""

msgid ""
"Starting from version :doc:`2.6.1 </release/2.6.1>`, Tarantool has the "
"built-in functionality managing automated leader election in a replica set. "
"This functionality increases the fault tolerance of the systems built on the"
" base of Tarantool and decreases dependency on the external tools for "
"replica set management."
msgstr ""
"Начиная с версии :doc:`2.6.1 </release/2.6.1>`, Tarantool обладает "
"встроенной функциональностью, позволяющей управлять автоматическими выборами"
" лидера (automated leader election) в наборе реплик. Это повышает "
"отказоустойчивость систем на базе Tarantool и снижает зависимость от внешних"
" инструментов управления набором реплик."

msgid "The following topics are described below:"
msgstr ""

msgid "Leader election and synchronous replication"
msgstr ""

msgid ""
"Leader election and synchronous replication are implemented in Tarantool as "
"a modification of the `Raft "
"<https://en.wikipedia.org/wiki/Raft_(computer_science)>`__ algorithm. Raft "
"is an algorithm of synchronous replication and automatic leader election. "
"Its complete description can be found in the `corresponding document "
"<https://raft.github.io/raft.pdf>`_."
msgstr ""
"В Tarantool используется модификация `Raft "
"<https://en.wikipedia.org/wiki/Raft_(computer_science)>`__, алгоритма "
"синхронной репликации и автоматического выбора лидера. Полное описание "
"алгоритма Raft можно найти `здесь <https://raft.github.io/raft.pdf>`_."

msgid ""
"In Tarantool, :ref:`synchronous replication <repl_sync>` and leader election"
" are supported as two separate subsystems. So it is possible to get "
"synchronous replication but use an alternative algorithm for leader "
"election. And vice versa -- elect a leader in the cluster but don't use "
"synchronous spaces at all. Synchronous replication has a separate "
":ref:`documentation section <repl_sync>`. Leader election is described "
"below."
msgstr ""
"В Tarantool :ref:`синхронная репликация<repl_sync>` и выборы "
"лидера реализованы как две независимые подсистемы. Это означает, что можно "
"настроить синхронную репликацию, а для выборов лидера использовать "
"альтернативный алгоритм — или, наоборот, применять механизм выборов лидера "
"кластера, но синхронные спейсы не использовать. Синхронной репликации "
"посвящён специальный :ref:`раздел документации <repl_sync>`. Ниже описан "
"процесс выборов лидера."

msgid "Leader election process"
msgstr ""

msgid ""
"Automated leader election in Tarantool helps guarantee that there is at most"
" one leader at any given moment of time in a replica set. A *leader* is a "
"writable node, and all other nodes are non-writable -- they accept read-only"
" requests exclusively. This can be useful when an application should not "
"support master-master replication but it is necessary to ensure that only "
"one node accepts new transactions and commits them successfully."
msgstr ""
"Автоматические выборы лидера в Tarantool гарантируют, что в каждый момент "
"времени в наборе реплик будет максимум один лидер. *Лидер* — это "
"единственный узел, доступный для записи. Все остальные узлы принимают "
"исключительно запросы на чтение. Такая конфигурация полезна, если в "
"приложении не должна поддерживаться репликация \"мастер-мастер\", но "
"необходимо, чтобы новые транзакции принимал и успешно фиксировал только один"
" узел."

msgid ""
"When :ref:`the election is enabled <repl_leader_elect_config>`, the life "
"cycle of a replica set is divided into so-called *terms*. Each term is "
"described by a monotonically growing number. After the first boot, each node"
" has its term equal to 1. When a node sees that it is not a leader and there"
" is no leader available for some time in the replica set, it increases the "
"term and starts a new leader election round."
msgstr ""
"Когда :ref:`функция выборов включена <repl_leader_elect_config>`, жизненный "
"цикл набора реплик делится на так называемые *термы*. Каждый терм "
"описывается монотонно растущим числом. После первой загрузки значение терма "
"каждого узла равно 1. Когда узел обнаруживает, что не является лидером и при"
" этом в наборе реплик уже какое-то время нет лидера, он увеличивает значение"
" своего терма и начинает новый тур выборов."

msgid ""
"*Leader election* happens via votes. The node which started the election "
"votes for itself and sends vote requests to other nodes. Upon receiving vote"
" requests, a node votes for the first of them, and then cannot do anything "
"in the same term but wait for a leader being elected."
msgstr ""

msgid ""
"The node that collected a :ref:`quorum of votes <repl_leader_elect_config>` "
"becomes the leader and notifies other nodes about that. Also, a split vote "
"can happen when no nodes received a quorum of votes. In this case, after a "
":ref:`random timeout <repl_leader_elect_config>`, each node increases its "
"term and starts a new election round if no new vote request with a greater "
"term arrives during this time period. Eventually, a leader is elected."
msgstr ""
"Узел, собравший :ref:`кворум голосов <repl_leader_elect_config>`, становится"
" лидером и оповещает об этом другие узлы. Если ни один узел не получает "
"достаточного количества голосов, спустя :ref:`случайное время "
"<repl_leader_elect_config>` происходят перевыборы: каждый узел увеличивает "
"значение терма и начинает новый тур, если за период ожидания не получил "
"запроса на голос от узла, чей терм больше. В итоге определяется лидер "
"кластера."

msgid ""
"All the non-leader nodes are called *followers*. The nodes that start a new "
"election round are called *candidates*. The elected leader sends heartbeats "
"to the non-leader nodes to let them know it is alive. So if there are no "
"heartbeats for a period set by the :ref:`replication_timeout "
"<cfg_replication-replication_timeout>` option, a new election starts. Terms "
"and votes are persisted by each instance in order to preserve certain Raft "
"guarantees."
msgstr ""
"Узлы, не являющиеся лидерами, называются *репликами* (followers). Узлы, "
"которые начинают новый тур выборов, называются *кандидатами* (candidates). "
"Избранный лидер отправляет остальным узлам контрольные сигналы, оповещая о "
"том, что он работает. Если контрольные сигналы не приходят в течение "
"времени, заданного параметром :ref:`replication_timeout <cfg_replication-"
"replication_timeout>`, начинаются новые выборы. Чтобы алгоритм Raft "
"гарантированно выполнялся, термы и голоса сохраняются на каждом экземпляре."

msgid ""
"During the election, the nodes prefer to vote for those ones that have the "
"newest data. So as if an old leader managed to send something before its "
"death to a quorum of replicas, that data wouldn't be lost."
msgstr ""

msgid ""
"When :ref:`election is enabled <repl_leader_elect_config>`, there must be "
"connections between each node pair so as it would be the full-mesh topology."
" This is needed because election messages for voting and other internal "
"things need direct connection between the nodes."
msgstr ""
"Когда :ref:`функция выборов включена <repl_leader_elect_config>`, "
"необходимо, чтобы все узлы были соединены попарно, образуя полную ячеистую "
"топологию. Чтобы передавать друг другу запросы, связанные с голосованием, и "
"другие внутренние сообщения, узлы должны быть соединены напрямую."

msgid ""
"Also, if an election is enabled on the node, it won't replicate from any "
"nodes except the newest leader. This is done to avoid the issue when a new "
"leader is elected, but the old leader has somehow survived and tries to send"
" more changes to the other nodes."
msgstr ""
"Кроме того, если на узле включена функция выборов, он будет копировать "
"данные только с последнего выбранного лидера. Это предупреждает конфликты в "
"случае, если прежний лидер каким-то образом выживает после выборов нового и "
"пытается отправлять изменения на другие узлы."

msgid ""
"Term numbers also work as a kind of a filter. For example, you can be sure "
"that if election is enabled on two nodes and ``node1`` has the term number "
"less than ``node2``, then ``node2`` won't accept any transactions from "
"``node1``."
msgstr ""

msgid "Configuration"
msgstr "Настройка"

msgid ""
"box.cfg({\n"
"    election_mode = <string>,\n"
"    election_timeout = <seconds>,\n"
"    replication_timeout = <seconds>,\n"
"    replication_synchro_quorum = <count>,\n"
"})"
msgstr ""

msgid ""
"``election_mode`` -- specifies the role of a node in the leader election "
"process. For the details, refer to the :ref:`option description "
"<cfg_replication-election_mode>` in the configuration reference."
msgstr ""

msgid ""
"``election_timeout`` -- specifies the timeout between election rounds if the"
" previous round ended up with a split vote. For the details, refer to the "
":ref:`option description <cfg_replication-election_timeout>` in the "
"configuration reference."
msgstr ""

msgid ""
"``replication_timeout`` -- reuse of the :ref:`replication_timeout "
"<cfg_replication-replication_timeout>` configuration option for the purpose "
"of the leader election process. Heartbeats sent by an active leader have a "
"timeout after which a new election starts. Heartbeats are sent once per "
"<replication_timeout> seconds. Default value is ``1``. The leader is "
"considered dead if it hasn't sent any heartbeats for the period of "
"``<replication_timeout> * 4``."
msgstr ""

msgid ""
"``replication_synchro_quorum`` -- reuse of the "
":ref:`replication_synchro_quorum <cfg_replication-"
"replication_synchro_quorum>` option for the purpose of configuring the "
"election quorum. The default value is ``1``, meaning that each node becomes "
"a leader immediately after voting for itself. It is the best to set up this "
"option value to the ``(<cluster size> / 2) + 1``. Otherwisem, there is no "
"guarantee that there is only one leader at a time."
msgstr ""

msgid ""
"Besides, it is important to know that being a leader is not the only "
"requirement for a node to be writable. A leader node should have its "
":ref:`read_only <cfg_basic-read_only>` option set to ``false`` "
"(``box.cfg{read_only = false}``), and its :ref:`connectivity quorum "
"<cfg_replication-replication_connect_quorum>` should be satisfied "
"(``box.cfg{replication_connect_quorum = <count>}``) or disabled "
"(``box.cfg{replication_connect_quorum = 0}``)."
msgstr ""

msgid ""
"Nothing prevents from setting the ``read_only`` option to ``true``, but the "
"leader just won't be writable then. The option doesn't affect the election "
"process itself, so a read-only instance can still vote and become a leader."
msgstr ""

msgid "Monitoring"
msgstr ""

msgid ""
"To monitor the current state of a node regarding the leader election, you "
"can use the ``box.info.election`` function. For details, refer to the "
":doc:`function description </reference/reference_lua/box_info/election>`."
msgstr ""

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"tarantool> box.info.election\n"
"---\n"
"- state: follower\n"
"  vote: 0\n"
"  leader: 0\n"
"  term: 1\n"
"..."
msgstr ""

msgid ""
"The Raft-based election implementation logs all its actions with the "
"``RAFT:`` prefix. The actions are new Raft message handling, node state "
"changing, voting, term bumping, and so on."
msgstr ""

msgid "Important notes"
msgstr ""

msgid ""
"Leader election won't work correctly if the election quorum is set to less "
"or equal than ``<cluster size> / 2`` because in that case, a split vote can "
"lead to a state when two leaders are elected at once."
msgstr ""

msgid ""
"For example, let's assume there are five nodes. When quorum is set to ``2``,"
" ``node1`` and ``node2`` can both vote for ``node1``. ``node3`` and "
"``node4`` can both vote for ``node5``. In this case, ``node1`` and ``node5``"
" both win the election. When the quorum is set to the cluster majority, that"
" is ``(<cluster size> / 2) + 1`` or bigger, the split vote is not possible."
msgstr ""

msgid ""
"That must be especially actual when adding new nodes. If the majority value "
"is changing, it's better to update the quorum on all the existing nodes "
"before adding a new one."
msgstr ""

msgid ""
"Also, the automated leader election won't bring many benefits in terms of "
"data safety when used *without* :ref:`synchronous replication <repl_sync>`. "
"If the replication is asynchronous and a new leader gets elected, the old "
"leader is still active and considers itself the leader. In such case, "
"nothing stops it from accepting requests from clients and making "
"transactions. Non-synchronous transactions will be successfully committed "
"because they won't be checked against the quorum of replicas. Synchronous "
"transactions will fail because they won't be able to collect the quorum -- "
"most of the replicas will reject these old leader's transactions since it is"
" not a leader anymore."
msgstr ""

msgid ""
"Another point to keep in mind is that when a new leader is elected, it won't"
" automatically finalize synchronous transactions left from the previous "
"leader. This must be done manually using the :ref:`box.ctl.promote <box_ctl-"
"promote>` function. In the future, it is going to be done automatically."
msgstr ""
